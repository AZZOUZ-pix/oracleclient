import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Created by dame on 05/10/2016.
 *
 */
public class OraclePaddingClient {
    static final Boolean RESPONSEIFERROR = false;

    CloseableHttpClient hgOraclePadClient = HttpClients.createDefault();
    String SERVER_URL = "http://localhost:8080/";
    String TARGETIP = "localhost";
    Integer TARGETPORT = 8080;

    /**
     * Sends query to Http server
     *
     * @param q String passed as argument to uri
     * @return Server Response Status Code
     */
    public boolean query(String q) throws IOException, URISyntaxException {
        URI uri = null;
        uri = new URIBuilder()
                .setScheme("http")
                .setHost(TARGETIP)
                .setPort(TARGETPORT)
                .setPath("/cbc/po")
                .setParameter("path", q)
                .build();

        HttpGet httpget = new HttpGet(uri);
        CloseableHttpResponse response = hgOraclePadClient.execute(httpget);

        int statuscode = response.getStatusLine().getStatusCode();
        response.close();

        boolean isPaddingGood;
        switch (statuscode) {
            case 200: // legitimate message
                isPaddingGood = true;
                break;
            case 404: // good padding, bad request
                isPaddingGood = true;
                break;
            case 403: // wrong padding
                isPaddingGood = RESPONSEIFERROR;
                break;
            default: // server issue
                isPaddingGood = true;
        }
        return isPaddingGood;
    }


    /**
     * Turns array of bytes into string hex representation
     *
     * @param buf Array of bytes to convert to hex string
     * @return Generated hex string
     */
    public static String stringAsHexFromBytes(byte buf[]) {
        StringBuilder strbuf = new StringBuilder(buf.length * 2);
        int i;
        for (i = 0; i < buf.length; i++) {
            if (((int) buf[i] & 0xff) < 0x10) {
                strbuf.append("0");
            }
            strbuf.append(Long.toString((int) buf[i] & 0xff, 16));
        }
        return strbuf.toString();
    }

    /**
     * Turns HEx representation into array of bytes
     *
     * @param hex String Hex representation to convert to Array of bytes
     * @return Generated byte array
     */
    public static byte[] bytesFromStringAsHex(String hex) {
        byte[] buf;

        Integer hexlen = hex.length() / 2;
        buf = new byte[hexlen];
        int i;
        for (i = 0; i < hexlen; i++) {
            String str = hex.substring(i * 2, i * 2 + 2);

            buf[i] = (byte) ((Character.digit(str.charAt(0), 16) << 4) + Character.digit(str.charAt(1), 16));
        }
        return buf;
    }


    public static void main(String[] args) {
        OraclePaddingClient opc = new OraclePaddingClient();

        String encryptedmessage = "28a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81";
        try {
            System.out.println("Server responded : " + opc.query(encryptedmessage));
        } catch (Exception e) {
            System.out.print("Exception from server");
            e.printStackTrace();
        }
    }
}

